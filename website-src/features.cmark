=base:build-info.json
{"layout":"article"
,"publicationStatus":"Public"
}

=base:preamble.json
{"author": "Lucas DiCioccio"
,"title": "Features list"
}

=base:topic.json
{"tags":["haskell", "authoring articles"]
,"keywords":["static-site generators", "design"]
}

=base:social.json
{"twitter": "lucasdicioccio"
,"linkedin": "lucasdicioccio"
,"github": "lucasdicioccio"
}

=base:main-css.css
@import "/css/dev.css";
@import "/css/colors.css";
@import "/css/article.css";
@import "/css/navigation.css";

section:not(:first-of-type) {
  border-left: 2px solid black;
  padding-left: 1em;
}

#histogram {
  height: 400px;
}

code {
  color: darksalmon;
  font-weight: bold;
}

code.language-console {
  color: darkgreen;
  font-weight: initial;
}

.op {
  color: rebeccapurple;
}

.dt {
  color: violet;
}

.cf {
  color: red;
}


=base:summary.cmark

This article lists the main features of Kitchen Sink. We do not really compare it to the vast amount of other static-site generators.

=base:main-content.cmark

Kitchen-Sink consists of two related components:
- i. a set of _libraries_ (at the time of writing, everything is packed in a single library: it's a kitchen sink afterall)
- ii. a default _executable_ which uses defaults from the library

The library allows you to write a program to author websites from content
thrown into a folder. The name Kitchen-Sink comes from the fact that Kitchen
Sink is meant to work with a single folder having no particular organization
besides filenames.

The executable imports the library to demonstrates and implements a
blog-generator generating HTML having a default layout (for this very website
for instance).  Thus, as a Kitchen-Sink user you could either run the
executable directly (if you want a website that looks like this one for
instance) or write your own executable from the library.

When we refer to _the Kitchen Sink engine_ or _the blog engine_, we thus refer
to features available from the libary. As of this writing, however, I have yet
to finish modularizing all these features. However, the following sections
provide a listing of features with a good overall structure of what could go in
which libraries.


=base:main-content.cmark
## command-line single-run mode

The default executable can run as a one-off generator command.  The intended
use-case if for generating websites as part of automated pipelines. There is
nothing really exciting about the command-line single-run mode.

Example usage with the default executable:

`kitchen-sink produce --srcDir website-src --outDir website-www`

```console
Loading (LoadArticle "website-src/features.cmark")
Loading (EvalSection "website-src/features.cmark" BuildInfo Json)
Loading (EvalSection "website-src/features.cmark" Preamble Json)
Loading (EvalSection "website-src/features.cmark" Topic Json)
Loading (EvalSection "website-src/features.cmark" Social Json)
Loading (EvalSection "website-src/features.cmark" MainCss Css)
Loading (EvalSection "website-src/features.cmark" Summary Cmark)
Loading (EvalSection "website-src/features.cmark" MainContent Cmark)
Loading (EvalSection "website-src/features.cmark" MainContent Cmark)
[...]
Assembling "website-www/features.html"
Assembling "website-www/topics/modding.html"
Assembling "website-www/topics/philosophy.html"
Assembling "website-www/topics/sections.html"
[...]
Generating "website-www/json/paths.json"
Generating "website-www/json/filecounts.json"
Generating "website-www/json/topicsgraph.json"
Generating "website-www/json/features.cmark.json"
Generating "website-www/json/philosophy.cmark.json"
[...]
```

These logs indicate that files where sourced in the `website-src` directory,
then computation occured, and finally files where output in the `website-www`
directory. You can navigate with a browser in this directory. However when
authoring articles it is pretty annoying to do manual refreshes. Instead,
Kitchen-Sink incorporates a server able to directly serve the same content as
it generates.

=base:main-content.cmark
## server-mode

One key reason for having written Kitchen-Sink is to explore things that makes
my life easy. Among these: live

### live-serving

Rather than generating all the website once, Kitchen-Sink can run an HTTP
server that will directly return the results of the output targets _on the
fly_.  That is, each time a web-browser navigates, the latest value for a given
route is shown to the browser. This is not especially useful but can come handy.

Example usage with the default executable:

`$ kitchen-sink serve --srcDir website-src --outDir website-www --servMode SERVE --port 7654`

```console
[...]
SiteReloaded (Init ())
SiteReloaded RunStart
TargetRequested "/features.html"
TargetBuilt "/features.html" 10079
GET /features.html
  Params: [("server-id","ca231c17-35c9-4060-b4f4-c0dd574dd325")]
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
  Status: 200 OK 0.029790833s
TargetRequested "/js/search-box.js"
TargetBuilt "/js/search-box.js" 260790
GET /js/search-box.js
  Accept: */*
  Status: 200 OK 0.000694164s
```

### auto-reload

The executable server has a special API route with a mechanism to wait for changes
of source files on the file-system.  We also bundle a [small JavaScript](/js/autoreload.js) that
subscribes to changes and reload the page on a change. This JavaScript gets
injected in the layout only in dev-server mode. This setup allows to auto-reload on change.

<video width="640" height="480" controls>
  <source src="/videos/auto-reload-002-liveedit.webm" type="video/webm">
  <source src="/videos/auto-reload-002-liveedit.mp4" type="video/mp4">
</video>

To use the dev-server mode, use `--servMode DEV`. That is, the full-command to run with the default executable is:

`kitchen-sink serve --srcDir website-src --outDir website-www --servMode DEV --port 7654`

### one-time commands

In addition to the above auto-reload script. The default executable's layout insert some buttons to get one-click.

- the `produce` button will regenerate the whole HTML output
- the `publish` button will call the `publishScript` command in the [kitchen-sink.json file](/kitchen-sink-dot-json.html) . As a data-point, I use [this publish-script](/gen/out/features.cmark__cat-publish-script) for this documentation site.

### it's just a webserver library
I've not really explored this avenue, but it should be possible to incorporate
the webserver logic in most Haskell web-applications (e.g., your
web-application could run an API and Kitchen-Sink could run some documentation
pages aside).

### server metrics

Why not? to build the webserver-library I've used some set of [curated and
bundled libraries named ProdAPI](https://github.com/lucasdicioccio/prodapi).
Which means the server inherits a number of features; among which a number of
[Prometheus counters](https://prometheus.io/). An example set of metrics is
available on [this
extract](/gen/out/features.cmark__gen-local-server-metrics.txt). Thus, rather
than bragging how much Kitchen-Sink is fast, you get to see for yourself
directly (e.g., with the `blog_fullbuild_time` counters in the Prometheus
summary). Other usages would be to track how fast you add content to articles
by collecting and storing the counters. For instance, this is a timeseries of
me editing this paragraph in live thanks to [a Firefox extension I
built](https://lucasdicioccio.github.io/prometheus-monitor.html).

![a timeseries graph showing the `blog_targets_sizes` prometheus counter](/images/features-001-targetsizes-timeseries.png)

=generator:cmd.json
{"cmd":"cat"
,"args":["scripts/publish.sh"]
,"target":"cat-publish-script"
}

=generator:cmd.json
{"cmd":"curl"
,"args":["http://localhost:7654/metrics"]
,"target":"gen-local-server-metrics.txt"
}

=base:main-content.cmark
## article authoring

Writing articles is the most important thing of a static-site generator.  The
[Kitchen-Sink Philosophy](/philosophy.html) here is to throw everything in one
file. The key, and probably somewhat unique aspect of Kitchen-Sink is to
propose writing articles, tune their CSS, provide tags, add generators and so
on directly in the same source file.

### the section-based format

The so-called section-based format has a [dedicated article](/sections.html) to
document specific mechanism.  In this article we merely show-off [the source
for this article](/gen/out/features.cmark__cat-features-cmark) to get an
impression of what writing _meaty content_ entails.

### tunable CSS per page

Among sections worth a "feature" label, a special section drives the
inlined-CSS of individual articles. In short, each article can have its own CSS
file.  I found that especially useful when I need to add some rules only for a
given article (e.g., alternating figure alignments) or when I want to host a
single-page JavaScript-app on an article only.  Thus, you should use `@import`
directives for CSS modularization and re-use across pages.  You do not lose
much in expressivity, a bit in performance, but you gain a lot in flexibility.

### CommonMark as main input articles

Writing articles is mostly done in [CommonMark](https://commonmark.org/). That
is, the _meaty content_ and some advanced analyses are based on CommonMark.

Besides the basics for headings, links, raw-HTML, _emphasis_, __boldness__, and `code`.
A number of extensions and additional extensions are enabled.

#### emojis :eyes:

Adding emojis is a way to incorporate some emotions in written-web content.
The list of `:emoji-codes:` is available [:arrow_right: here :arrow_left:](https://gist.github.com/rxaviers/7360908) :fire:.

#### delimited blocks divs with attributes 

Which allow to add some CSS classes, and HTML identifiers

For instance:

    ::: {.todo #smalldiv}
      add something
    :::

generates the following code

```html
<div id="smalldiv" class="todo">
<p>add something</p>
</div>
```

which can then be styled in CSS.

#### syntax highlighting with `skylighting`

Code-blocks are analyzed by [skylighting](https://github.com/jgm/skylighting),
which tokenize code and wraps resulting code with HTML tags having some
well-defined classes for styling in CSS.

```c
int main(int argc, char** argv) {
  return 0;
}
```

Overall I found that skylighting does the job and since the library requires no
extra JavaScript on the resulting website or external-dependencies at
code-generation time: it's good.

### copies other images, css

An article often comes with extra medias. Images (with `jpeg`, `png`
extensions), JavaScript (`.js`) and CSS (`.css`) files are copied to
their own target at known location.  That is, KitchenSink wants everything in a
directory but applies rule so that you get something a bit cleaner in return,
isn't it awesome?

You can see for yourself, compare the [listing of this website source directory](/gen/out/features.cmark__tree-site-input-cmark.json) with the [listing of the website output directory](/gen/out/features.cmark__tree-site-output-cmark.json) (courtesy of `tree -J`).

### generate images from `.dot`

There is a special room in my heart for [GraphViz](https://graphviz.org/) :heart:. I use it a lot to render diagrams and illustrate simple ideas. Thus I found natural to add some special support for files with the `.dot` extensions.

![all in the kitchen-sink](/gen/images/features-002-dot-demo.dot.png)

Coupled with [auto-reload](#auto-reload), GraphViz-made diagrams work well
enough to edit technical articles without ever leaving my editor as illustrated in the following video:

<video width="640" height="480" controls>
  <source src="/videos/auto-reload-001-dot.mp4" type="video/mp4">
  <source src="/videos/auto-reload-001-dot.webm" type="video/webm">
</video>

=generator:cmd.json
{"cmd":"tree"
,"args":["-J", "website-src"]
,"target":"tree-site-input-cmark.json"
}

=generator:cmd.json
{"cmd":"tree"
,"args":["-J", "website-www"]
,"target":"tree-site-output-cmark.json"
}

=generator:cmd.json
{"cmd":"cat"
,"args":["website-src/features.cmark"]
,"target":"cat-features-cmark"
}


=base:main-content.cmark
## content-generation

The core-business of a static-site generator is to generate HTML output from
various input.  Thus, we could pedentically say that all content is
"generated". Here we discuss cases where Kitchen-Sink goes the extra-mile to
provide extra features.

### embedded data

Kitchen-Sink generate a host of data while assembling targets from input files.
Intermediary-representations. In particular, there is a `json` file generated
with each HTML article and is linked in the HTML `meta` tag with name
`ks:article_json`. So that individual scripts can then locate these
information. As we get more mileage, we'll likely add more of such paths and
formalize a bit their expected content.  However, keep in mind that
Kitchen-Sink generates more than just the static aspects of the HTML: it
provides a bunch of extra information.

### command-based generators

In this article I've already pointed to a number of links (e.g., the source of
this article, some directory listings).  In short, you can add one-off data
collections that produce their own targets.

A typical usage is to turn some information about the system generating the
blog (e.g. `uname -a`). However you could get creative such as
- fetch the latest news-article
- run some database query to be displayed in javascript later
- taking a [selfie](/gen/out/features.cmark__latest-selfie.jpg) on demand (yes, this picture happens to be my face when I generate this website -- hat tip to `fswebcam`)

### microscriptable in Dhall

I have written a [full article](https://lucasdicioccio.github.io/dhall-section-demo.html) on my personal blog a while ago to motivate the whole usage of [Dhall](https://dhall-lang.org/). Keep in mind that I'm still happy about the choice. Dhall "powers" my photo galleries and my [stream of notes](https://lucasdicioccio.github.io/notes.html) on my personal blog.

=generator:cmd.json
{"cmd":"fswebcam"
,"args":["-r", "320x240", "--jpeg", "85", "-D", "1", "/dev/stdout"]
,"target":"latest-selfie.jpg"
}


=base:main-content.cmark
## article organization

### article summaries
### social links
### open-graph and twitter-card metas
### special-support for dotfiles
### categories using tags


=base:main-content.cmark
## content-analysis

### site listing and search-box
### wordcounts
### sitemap graph
### article skylines

::: {#histogram}
:::

<script src="/js/echarts.min.js"></script>
<script src="/js/echart-histogram.js"></script>
